---
layout: post
title: SQL Server Table Partition
date: 2012-04-27 10:20
author: techforumugm
comments: true
categories: [MS SQLServer]
---
<div style="line-height:18pt;text-align:justify;"><span><u><span style="font-family:'Arial Narrow', 'sans-serif';">What is Table Partition ?</span></u><span style="font-family:'Arial Narrow', 'sans-serif';"></span></span></div><div style="line-height:18pt;text-align:justify;text-indent:-.25in;"><span><span style="font-family:'Arial Narrow', 'sans-serif';">¢</span><span style="font-family:'Arial Narrow', 'sans-serif';">    </span><span style="font-family:'Arial Narrow', 'sans-serif';">Partitioning is the database process or method where very large tables and indexes are divided in multiple smaller and manageable parts. SQL Server allows to partition tables using defined ranges and also provides management features and tools to keep partition tables in optimal performance.</span><span style="font-family:'Arial Narrow', 'sans-serif';"></span></span></div><div style="line-height:18pt;text-align:justify;"><br /></div><div style="line-height:18pt;text-align:justify;"><span><u><span style="font-family:'Arial Narrow', 'sans-serif';">How Table is Partitioned ?</span></u><span style="font-family:'Arial Narrow', 'sans-serif';"></span></span></div><div style="line-height:18pt;text-align:justify;text-indent:-.25in;"><span><span style="font-family:'Arial Narrow', 'sans-serif';">¢</span><span style="font-family:'Arial Narrow', 'sans-serif';">    </span><span style="font-family:'Arial Narrow', 'sans-serif';">The data of partitioned tables and indexes is divided into units that can be spread across more than one filegroup in a database. The data is partitioned horizontally, so that groups of rows are mapped into individual partitions. The table or index is treated as a single logical entity when queries or updates are performed on the data. All partitions of a single index or table must reside in the same database.</span><span style="font-family:'Arial Narrow', 'sans-serif';"></span></span></div><div style="line-height:18pt;text-align:justify;"><br /></div><div style="line-height:18pt;text-align:justify;"><span><u><span style="font-family:'Arial Narrow', 'sans-serif';">When Table Partition is Required?</span></u><span style="font-family:'Arial Narrow', 'sans-serif';"></span></span></div><div style="line-height:18pt;text-align:justify;"><span><span style="font-family:'Arial Narrow', 'sans-serif';">Generally, a large table might be appropriate for partitioning if both of the following are true: </span><span style="font-family:'Arial Narrow', 'sans-serif';"></span></span></div><div style="line-height:18pt;text-align:justify;"><span><span style="font-family:'Arial Narrow', 'sans-serif';">        1.  The table contains, or is expected to contain, lots of data that are used in different ways.</span><span style="font-family:'Arial Narrow', 'sans-serif';"></span></span></div><div style="line-height:18pt;text-align:justify;"><span><span style="font-family:'Arial Narrow', 'sans-serif';">        2.   partitioning a table or index might improve query performance if the partitions are  designed correctly, based on the types of queries you frequently run and on your hardware configuration.  </span><span style="font-family:'Arial Narrow', 'sans-serif';"></span></span></div><div style="line-height:18pt;text-align:justify;"><span><span style="font-family:'Arial Narrow', 'sans-serif';">        3.  Queries or updates against the table are not performing as intended, or maintenance   costs exceed predefined maintenance periods. </span><span style="font-family:'Arial Narrow', 'sans-serif';"></span></span></div><div style="line-height:18pt;"><br /></div><div style="line-height:18pt;"><u><span style="font-family:'Arial Narrow', 'sans-serif';"><span>When Partition is not required</span></span></u><span style="font-family:'Arial Narrow', 'sans-serif';"><br /><span>While partitioning can offer great benefits, it adds administrative overhead and complexity to the implementation of your objects, which can be more of a burden than a gain. Specifically, you might not want to partition a small table, or a table that currently meets performance and maintenance requirements.Partitioning to relieve the burden of moving rows and data—you should consider whether your scenario has this sort of burden when deciding whether to implement partitioning</span></span><span style="font-family:'Arial Narrow', 'sans-serif';"></span></div><div style="line-height:18pt;"><br /></div><div style="line-height:18pt;"><span><u><span style="color:#1f497d;font-family:'Arial Narrow', 'sans-serif';font-variant:small-caps;">Steps For Table Partition</span></u><span style="font-family:'Arial Narrow', 'sans-serif';"></span></span></div><div style="line-height:18pt;"><br /></div><div style="line-height:18pt;"><br /></div><div style="line-height:18pt;"><span style="font-family:'Arial Narrow', 'sans-serif';"><span>Step 1 : Create New Test Database with two different filegroups<br />I have written tutorial using my C: Drive, however to take advantage of partition it is recommended that different file groups are created on separate hard disk to get maximum performance advantage of partitioning. Before running following script, make sure C: drive contains two folders – Primary and Secondary as following example has used those two folder to store different filegroups.<br />USE Master;<br />GO<br />--- Step 1 : Create New Test Database with two different filegroups.<br />IF EXISTS (<br />SELECT name<br />FROM sys.databases<br />WHERE name = N'TestDB')<br />DROP DATABASE TestDB;<br />GO<br />CREATE DATABASE TestDB<br />ON PRIMARY<br />(NAME='TestDB_Part1',<br />FILENAME=<br />'C:\Data\Primary\TestDB_Part1.mdf',<br />SIZE=2,<br />MAXSIZE=100,<br />FILEGROWTH=1 ),<br />FILEGROUP TestDB_Part2<br />(NAME = 'TestDB_Part2',<br />FILENAME =<br />'C:\Data\Secondary\TestDB_Part2.ndf',<br />SIZE = 2,<br />MAXSIZE=100,<br />FILEGROWTH=1 );<br />GO</span></span></div><div style="line-height:18pt;"><br /></div><div style="line-height:18pt;vertical-align:baseline;"><span style="font-family:'Arial Narrow', 'sans-serif';"><span>Partition Function defines the range of values to be stored on different partition. For our example let us assume that first 10 records are stored in one filegroup and rest are stored in different filegroup. Following function will create partition function with range specified.</span></span></div><div style="line-height:18pt;vertical-align:baseline;"><span style="font-family:'Arial Narrow', 'sans-serif';"><span>USE TestDB;<br />GO<br />--- Step 2 : Create Partition Range Function<br />CREATE PARTITION FUNCTION TestDB_PartitionRange (INT)<br />AS RANGE LEFT FOR<br />VALUES (10);<br />GO</span></span></div><div style="line-height:18pt;vertical-align:baseline;"><br /></div><div style="line-height:18pt;vertical-align:baseline;"><span style="font-family:'Arial Narrow', 'sans-serif';"><span>Step 4 : Create Table with Partition Key and Partition Scheme</span></span></div><div style="line-height:18pt;vertical-align:baseline;"><br /></div><div style="line-height:18pt;margin:6pt 0 0 .3in;text-indent:-.3in;vertical-align:baseline;"><span style="font-family:'Arial Narrow', 'sans-serif';"><span><span>   </span>The table which is to be partitioned has to be created specifying column name to be used with partition scheme to partition tables in different filegroups. Following example demonstrates ID column as the Partition Key.<br />USE TestDB;<br />GO<br />--- Step 4 : Create Table with Partition Key and Partition Scheme<br />CREATE TABLE TestTable<br />(ID INT NOT NULL,<br />Date DATETIME)<br />ON TestDB_PartitionScheme (ID);<br />GO</span></span></div><div style="line-height:18pt;margin:6pt 0 0 .3in;text-indent:-.3in;vertical-align:baseline;"><br /></div><div style="line-height:18pt;margin:6pt 0 0 .3in;text-indent:-.3in;"><span style="font-family:'Arial Narrow', 'sans-serif';"><span><span>    </span>Step 5 : (Optional/Recommended) Create Index on Partitioned Table</span></span></div><div style="line-height:18pt;margin:6pt 0 0 .3in;text-indent:-.3in;"><span style="font-family:'Arial Narrow', 'sans-serif';"><br /><span>This step is optional but highly recommended. Following example demonstrates the creation of table aligned index. Here index is created using same Partition Scheme and Partition Key as Partitioned Table.<br />USE TestDB;<br />GO<br />--- Step 5 : (Optional/Recommended) Create Index on Partitioned Table<br />CREATE UNIQUE CLUSTERED INDEX IX_TestTable<br />ON TestTable(ID)<br />ON TestDB_PartitionScheme (ID);<br />GO<br /><br />Step 6 : Insert Data in Partitioned Table</span></span></div><div style="line-height:18pt;margin:6pt 0 0 .3in;text-indent:-.3in;"><span style="font-family:'Arial Narrow', 'sans-serif';"><br /><span>Insert data in the partition table. Here we are inserting total of 3 records. We have decided that in table partition 1 Partition Key ID will contain records from 1 to 10 and partition 2 will contain reset of the records. In following example record with ID equals to 1 will be inserted in partition 1 and rest will be inserted in partition 2.<br />USE TestDB;<br />GO<br />--- Step 6 : Insert Data in Partitioned Table<br />INSERT INTO TestTable (ID, Date) -- Inserted in Partition 1<br />VALUES (1,GETDATE());<br />INSERT INTO TestTable (ID, Date) -- Inserted in Partition 2<br />VALUES (11,GETDATE());<br />INSERT INTO TestTable (ID, Date) -- Inserted in Partition 2<br />VALUES (12,GETDATE());<br />GO</span></span></div><div style="line-height:18pt;margin:6pt 0 0 .3in;text-indent:-.3in;"><br /></div><div style="line-height:18pt;margin:6pt 0 0 .3in;text-indent:-.3in;"><span style="font-family:'Arial Narrow', 'sans-serif';"><span>Step 7 : Test Data from TestTable</span></span></div><div style="line-height:18pt;margin:6pt 0 0 .3in;text-indent:-.3in;"><span style="font-family:'Arial Narrow', 'sans-serif';"><span>Query TestTable and see the values inserted in TestTable.<br />USE TestDB;<br />GO<br />--- Step 7 : Test Data from TestTable<br />SELECT *<br />FROM TestTable;<br />GO </span></span></div><div style="line-height:18pt;margin:6pt 0 0 .3in;text-indent:-.3in;"><span style="font-family:'Arial Narrow', 'sans-serif';"><span>Step 8 : Verify Rows Inserted in Partitions</span></span></div><div style="line-height:18pt;margin:6pt 0 0 .3in;text-indent:-.3in;"><span style="font-family:'Arial Narrow', 'sans-serif';"><span>We can query sys.partitions view and verify that TestTable contains two partitions and as per Step 6 one record is inserted in partition 1 and two records are inserted in partition 2.<br />USE TestDB;<br />GO<br />--- Step 8 : Verify Rows Inserted in Partitions<br />SELECT *<br />FROM sys.partitions<br />WHERE OBJECT_NAME(OBJECT_ID)='TestTable';<br />GO</span></span></div><div class="MsoNormal" style="margin:0 0 10pt;"><br /></div>
